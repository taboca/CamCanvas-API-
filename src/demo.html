<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Webcam Canvas – Fullscreen Stack + Fade</title>
<style>
  html, body { height: 100%; margin: 0; background: #000; }
  /* All canvases cover the viewport and stack */
  canvas[data-webcam-filter] {
    position: fixed; inset: 0; width: 100vw; height: 100vh;
    display: block;
    transition: opacity 2s linear;   /* 2s fade */
    opacity: 1;                      /* start visible */
    /* Optional: avoid mouse capture */
    pointer-events: none;
  }
</style>
</head>
<body>

<!-- Your canvases (unchanged API) -->
<canvas data-webcam-filter="emboss"  width="320" height="240"></canvas>
<canvas data-webcam-filter="gray"    width="320" height="240"></canvas>
<canvas data-webcam-filter="red"     width="320" height="240"></canvas>
<canvas data-webcam-filter="inverse" width="320" height="240"></canvas>

<!-- Load your existing API (no changes inside this file) -->
<script src="camcanvas.js"></script>

<!-- Add this small helper AFTER the API -->
<script>
(function(){
  // Ensure this runs after WebcamFX auto-inits
  window.addEventListener('load', () => {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const canvases = Array.from(document.querySelectorAll('canvas[data-webcam-filter]'));
    if (!canvases.length) return;

    // 1) Make every canvas truly full-screen (canvas pixels, not just CSS)
    function resizeAll() {
      const w = Math.floor(window.innerWidth  * dpr);
      const h = Math.floor(window.innerHeight * dpr);
      canvases.forEach(cv => {
        // Set internal drawing buffer to viewport size for crisp rendering
        cv.width  = w;
        cv.height = h;
        // CSS size already 100vw/100vh via styles
      });
    }
    resizeAll();
    window.addEventListener('resize', resizeAll);

    // 2) Stack with increasing z-index so the last one is on top initially
    canvases.forEach((cv, i) => cv.style.zIndex = String(1000 + i));

    // 3) Fading loop:
    //    - Pick the current top canvas (max zIndex)
    //    - Fade it to 0 over 2s (via CSS transition)
    //    - On transition end: send it to the back (lowest z), restore opacity=1
    //    - Repeat forever
    function getTopIndex() {
      let max = -Infinity, idx = 0;
      canvases.forEach((cv, i) => {
        const z = parseInt(cv.style.zIndex || '0', 10);
        if (z > max) { max = z; idx = i; }
      });
      return idx;
    }

    // Normalized z-indices: 1000 .. 1000 + n-1
    function normalizeZ() {
      const sorted = [...canvases].sort((a,b) =>
        parseInt(a.style.zIndex||'0',10) - parseInt(b.style.zIndex||'0',10)
      );
      sorted.forEach((cv, i) => cv.style.zIndex = String(1000 + i));
    }

    let busy = false;

    function cycleOnce() {
      if (busy) return;
      busy = true;

      const topIdx = getTopIndex();
      const top = canvases[topIdx];

      // Start fade-out
      top.style.opacity = '0';

      // When the 2s transition ends, push to back & restore opacity
      const onEnd = (ev) => {
        if (ev.propertyName !== 'opacity') return;
        top.removeEventListener('transitionend', onEnd);

        // Move the just-faded canvas behind everyone else
        // 1) Make it lowest z
        const currentZs = canvases.map(cv => parseInt(cv.style.zIndex||'0',10));
        const minZ = Math.min.apply(null, currentZs);
        top.style.zIndex = String(minZ - 1);

        // 2) Restore opacity so it’s ready to be visible next time it climbs up
        //    (It will naturally become visible again as it cycles back to the top)
        //    We set to 1 instantly (transition still applies; it's fine for a subtle rise)
        top.style.opacity = '1';

        // 3) Repack z-indices to a clean 1000.. range
        normalizeZ();

        busy = false;

        // Small delay before next fade to avoid overlapping transitions
        setTimeout(cycleOnce, 50);
      };

      top.addEventListener('transitionend', onEnd, { once: true });
    }

    // Kick off the loop (fade one after another forever)
    // Optional cadence: start, then schedule next on each transitionend.
    cycleOnce();

    // If you prefer a steady cadence (e.g., every 2200ms), uncomment:
    // setInterval(cycleOnce, 2200);
  });
})();
</script>

</body>
</html>
